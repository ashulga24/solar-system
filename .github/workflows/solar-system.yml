name: Solar System workflow

on:
    workflow_dispatch:
    push:
        branches:
            - main
            - 'feature/*'

env:
    MONGO_URI: "mongodb+srv://supercluster.d83jj.mongodb.net/superData"
    MONGO_USERNAME: ${{ vars.MONGO_USERNAME }}
    MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}

jobs:
    unit-testing:
        name: Unit testing
        strategy:
            matrix:
                nodejs_version: [18, 19, 20]
                operating_system: [ubuntu-latest, macos-latest]
                exclude:
#                    - nodejs_version: 18
                    -  operating_system: macos-latest
        runs-on: ubuntu-latest
        steps:
            - name: Chekout Repo
              uses: actions/checkout@v4

            - name: setup NodeJS Version - ${{ matrix.nodejs_version }}
              uses: actions/setup-node@v3
              with:
                node-version: ${{ matrix.nodejs_version }}

                # we need to create a unique key on VM type where we do chaching, as we run different OS types
                # so we use `name of the machine-node-modules-hash-of-package.json-file`
                # so wehnever file changes - we would invalidate cache and create new cache
                # and it would be clear bsaed on hash that file has changed
            - name: Cache NPM dependencies
              uses: actions/cache@v3
              with:
                path: node_modules # ~/.npm
                key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}

            - name: Install Dependencies
              run: npm install

            - name: Unit Testing
              id: nodejs-unit-testing-step
              run: npm test

            - name: show files generated
              run: ls -la
# the condition we used is excessive, it is just for test.
# it says that this step should be executed only `on failure` and ....
# so this step would be SKIPPED! from execution!
            # - name: Archive Test Result
            #   if: failure() && ( steps.nodejs-unit-testing-step.outcome == 'failure' || steps.nodejs-unit-testing-step.outcome == 'success' )
            #   uses: actions/upload-artifact@v3
            #   with:
            #     name: Mocha-Test-Result
            #     path: test-result.xml

# instead we would use `always()` so the step would ALWAYS be executed, despite
# the outcomes of previous step and the results would always be stored
            - name: Archive Test Result
              if: always()
              uses: actions/upload-artifact@v3
              with:
                  name: Mocha-Test-Result
                  path: test-results.xml

    code-coverage:
        name: Code Coverage
        strategy:
            matrix:
                nodejs_version: [18, 19, 20]
                operating_system: [ubuntu-latest, macos-latest]
                exclude:
      #              - nodejs_version: 18
                    -  operating_system: macos-latest
        runs-on: ubuntu-latest
        steps:
            - name: Chekout Repo
              uses: actions/checkout@v4

            - name: setup NodeJS Version - ${{ matrix.nodejs_version }}
              uses: actions/setup-node@v3
              with:
                node-version: ${{ matrix.nodejs_version }}

                # same as above
            - name: Cache NPM dependencies
              uses: actions/cache@v3
              with:
                  path: node_modules # ~/.npm
                  key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}

            - name: Install Dependencies
              run: npm install

            - name: Check Code Coverage
              run: npm run coverage
              continue-on-error: true

            - name: Archive Test Result
              uses: actions/upload-artifact@v3
              with:
                name: Code-Coverage-Result
                path: coverage
                retention-days: 5

    docker:
        name: Containerization
        runs-on: ubuntu-latest
        needs: [ code-coverage, unit-testing ]
# this         
        permissions:
          packages: write
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Dockerhub login
              uses: docker/login-action@v2.2.0
              with:
                username: ${{ vars.DOCKER_USERNAME }}
                password: ${{ secrets.DOCKER_PASS }}

# github token is automatically generated when each WF is running!
# ${{ github.repository_owner }} - already contains username
# for each WF job guthub actomatically creates a GITHUB_TOKEN which is valid 24H
# which can be used in workflows.
# and this token is used to authenticate on behalf of you in WF job
# each token has some perissions (like read ) by defult.
# if we want to extend permissions with wrtie, we heed to add `permissions` sections, like
# jobs:
#   triage:
#     runs-on: ubuntu-latest
#     permissions:
#       contents: write
#       pull-request: write

            - name: GHCR login
              uses: docker/login-action@v2.2.0
              with:
                registry: ghcr.io
                username: ${{ github.repository_owner }}
                password: ${{ secrets.GITHUB_TOKEN }}
              
            - name: Docker build for testing
              uses: docker/build-push-action@v4
              with:
                context: .
                push: false
                tags: ${{ vars.DOCKER_USERNAME }}/solar-system:${{ github.sha }}

            - name: Docker Image Test
              run: |
                docker images
                docker run --name solar-system-app -d \
                  -p 3000:3000 \
                  -e MONGO_URI=$MONGO_URI \
                  -e MONGO_USERNAME=$MONGO_USERNAME \
                  -e MONGO_PASSWORD=$MONGO_PASSWORD \
                  ${{ vars.DOCKER_USERNAME }}/solar-system:${{ github.sha }}

                export IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' solar-system-app)
                echo $IP

                echo Testing Image URL using wget
                wget -q -O - 127.0.0.1:3000/live | grep live

# disabled in favor of step pushing to GHCR.io
            # - name: Docker push
            #   uses: docker/build-push-action@v4
            #   with:
            #     context: .
            #     push: false # true
            #     tags: ${{ vars.DOCKER_USERNAME }}/solar-system:${{ github.sha }}

# To publish images accosiated with WF into GitHub Container Registry (GHCR) - we need GitHub token to  authenticate,
#
# And a personal access token (classic) with at least `read:packages` scope to install packages associated
# with other private repositories (which GITHUB_TOKEN can't access).
# $ export $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin
# where USERNAME is your account name
# password - github token
# $ docker push ghcr.io/NAMESPACE/IMAGE_NAME_:latest


# this way we can push to 2 several registries in one step
            - name: Pushing to Docker Hub and to Github Container Registry GHCR.io
              uses: docker/build-push-action@v4
              with:
                context: .
                push: true
                tags: |
                    ${{ vars.DOCKER_USERNAME }}/solar-system:${{ github.sha }}
                    "ghcr.io/${{ github.repository_owner }}/solar-system:${{ github.sha }}"